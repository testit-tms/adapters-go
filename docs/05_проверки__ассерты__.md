# Chapter 5: Проверки (Ассерты)


В [предыдущей главе](04_подготовка_и_завершение__фикстуры__.md) мы научились организовывать подготовку (`tms.BeforeTest`) и очистку (`tms.AfterTest`) для наших тестов. Теперь, когда у нас есть структура "подготовка -> тест -> завершение", и сам тест разбит на [Шаги Теста](03_шаги_теста_.md), пришло время поговорить о самом главном в любом тесте — о **проверках**. Как убедиться, что наша программа работает *правильно*?

Представьте, что вы на заводе проверяете качество детали. У вас есть чертеж с размерами (ожидаемый результат). Вы берете деталь (фактический результат) и измеряете ее штангенциркулем (выполняете проверку). Если размеры совпадают — деталь качественная (тест пройден). Если нет — брак (тест упал). Просто выполнить действия (например, изготовить деталь) недостаточно, нужно **убедиться**, что результат соответствует ожиданиям.

В автоматических тестах роль таких "измерительных инструментов" играют **проверки**, или **ассерты** (от англ. assert — утверждать). Библиотека `adapters-go` предоставляет набор удобных функций-оберток (`tms.True`, `tms.Equal`, `tms.NoError` и т.д.) над популярной библиотекой `testify/assert`. Но они делают больше, чем просто проверяют условие. Если проверка не проходит:

1.  Они помечают тест как **упавший** (`t.Fail()`).
2.  **Автоматически** записывают подробное сообщение об ошибке и информацию о месте падения в результат теста.
3.  Эта информация затем **отправляется в Test IT**, что сильно упрощает анализ неудачных тестов.

Это как если бы ваш штангенциркуль при обнаружении брака не только подавал сигнал, но и автоматически делал запись в журнале: "Деталь №5, проверка длины, ожидалось 10.0 мм, получено 10.2 мм, время 10:35, линия сборки №2".

В этой главе мы разберем:
*   Зачем нужны специальные ассерты `tms`?
*   Как использовать основные функции проверок (`tms.Equal`, `tms.True`, `tms.Nil` и др.)?
*   Что происходит "под капотом", когда проверка не проходит?

## Зачем нужны обертки `tms` над `testify/assert`?

В стандартном Go-тестировании вы можете использовать пакет `testing` и писать проверки вручную:

```go
package examples

import "testing"

func TestAdditionWithoutTmsAsserts(t *testing.T) {
	result := 2 + 2
	expected := 4
	if result != expected {
		// Нужно вручную формировать сообщение и вызывать t.Errorf
		t.Errorf("Ожидали %d, но получили %d", expected, result)
	}
}
```

Это работает, но есть недостатки:
*   Нужно писать `if` для каждой проверки.
*   Нужно вручную формировать информативное сообщение об ошибке в `t.Errorf` или `t.Fatalf`.
*   Информация, отправляемая в Test IT, может быть менее структурированной.

Библиотека `testify/assert` значительно упрощает это:

```go
package examples

import (
	"testing"
	"github.com/stretchr/testify/assert" // Используем testify
)

func TestAdditionWithTestify(t *testing.T) {
	result := 2 + 2
	expected := 4
	// assert.Equal сама проверяет и вызывает t.Errorf с хорошим сообщением
	assert.Equal(t, expected, result, "Проверка сложения")
}
```

Это уже намного лучше! Но `adapters-go` идет еще дальше. Функции `tms.*` используют `testify/assert` внутри, но добавляют интеграцию с Test IT:

```go
package examples

import (
	"testing"
	"github.com/testit-tms/adapters-go" // Наш адаптер
)

func TestAdditionWithTmsAsserts(t *testing.T) {
	// Используем метаданные и tms.Test из предыдущих глав
	meta := tms.TestMetadata{DisplayName: "Проверка сложения с tms.Assert"}
	tms.Test(t, meta, func() {
		result := 2 + 2
		expected := 4
		// Используем tms.Equal
		tms.Equal(t, expected, result, "Проверяем 2 + 2 = 4") // Неудачная проверка запишет ошибку для Test IT
	})
}
```

Ключевое преимущество: если `tms.Equal` завершится неудачно, адаптер **автоматически** запишет в результат теста (который уйдет в Test IT) не только сообщение "Not equal: expected 4, actual 5", но и **место в коде**, где произошла ошибка (stack trace). Это очень помогает при отладке.

## Основные функции проверок

Адаптер `adapters-go` предоставляет обертки для большинства популярных функций из `testify/assert`. Вот некоторые из самых часто используемых:

*   **`tms.True(t, value bool, msgAndArgs ...interface{})`**: Проверяет, что `value` истинно (`true`).
    ```go
    isValid := user.IsActive()
    tms.True(t, isValid, "Пользователь должен быть активен")
    ```
*   **`tms.False(t, value bool, msgAndArgs ...interface{})`**: Проверяет, что `value` ложно (`false`).
    ```go
    isAdmin := user.IsAdmin()
    tms.False(t, isAdmin, "Пользователь не должен быть админом")
    ```
*   **`tms.Equal(t, expected, actual interface{}, msgAndArgs ...interface{})`**: Проверяет, что `expected` и `actual` равны (используя `==` или метод `Equal`, если он есть). Сравнивает значения.
    ```go
    count := getItemsCount()
    tms.Equal(t, 10, count, "Должно быть 10 элементов")
    ```
*   **`tms.NotEqual(t, expected, actual interface{}, msgAndArgs ...interface{})`**: Проверяет, что `expected` и `actual` не равны.
    ```go
    oldPassword := "pass1"
    newPassword := "pass2"
    tms.NotEqual(t, oldPassword, newPassword, "Новый пароль не должен совпадать со старым")
    ```
*   **`tms.Nil(t, object interface{}, msgAndArgs ...interface{})`**: Проверяет, что `object` равен `nil`.
    ```go
    err := processData()
    tms.Nil(t, err, "Ошибки при обработке данных быть не должно") // Часто используется для проверки ошибок
    ```
*   **`tms.NotNil(t, object interface{}, msgAndArgs ...interface{})`**: Проверяет, что `object` не равен `nil`.
    ```go
    user, err := findUser("test")
    tms.Nil(t, err) // Проверили ошибку
    tms.NotNil(t, user, "Пользователь 'test' должен быть найден")
    ```
*   **`tms.NoError(t, err error, msgAndArgs ...interface{})`**: Более явный способ проверить, что ошибка (`err`) равна `nil`. Эквивалентно `tms.Nil`.
    ```go
    err := setupDatabase()
    tms.NoError(t, err, "Настройка базы данных должна пройти без ошибок")
    ```
*   **`tms.Error(t, err error, msgAndArgs ...interface{})`**: Проверяет, что ошибка (`err`) *не* равна `nil`.
    ```go
    err := deleteNonExistentFile()
    tms.Error(t, err, "Должна быть ошибка при удалении несуществующего файла")
    ```
*   **`tms.Contains(t, s, contains interface{}, msgAndArgs ...interface{})`**: Проверяет, что строка `s`, срез (slice) или карта (map) `s` содержит элемент (подстроку) `contains`.
    ```go
    message := "User logged in successfully"
    tms.Contains(t, message, "successfully", "Сообщение должно содержать 'successfully'")

    permissions := []string{"read", "write"}
    tms.Contains(t, permissions, "read", "Должно быть право на чтение")
    ```
*   **`tms.Len(t, object interface{}, length int, msgAndArgs ...interface{})`**: Проверяет, что длина объекта `object` (строки, среза, карты, канала) равна `length`.
    ```go
    users := getUsers()
    tms.Len(t, users, 5, "Должно быть ровно 5 пользователей")
    ```

**Общий шаблон использования:**
`tms.ИмяПроверки(t, [ожидаемое_значение, если нужно], фактическое_значение, [необязательное_сообщение, аргументы...])`

*   `t`: Всегда передается стандартный `*testing.T`.
*   `ожидаемое_значение`: То, что вы ожидаете получить (для `Equal`, `Len` и т.д.).
*   `фактическое_значение`: То, что вернула ваша проверяемая функция.
*   `необязательное_сообщение`: Строка (с опциональными форматерами типа `%d`, `%s`) и аргументы к ней. Это сообщение будет добавлено к стандартному сообщению об ошибке, если проверка упадет.

Полный список доступных функций-проверок можно найти в файле `assert.go` библиотеки `adapters-go`. Они покрывают почти все потребности в проверках.

## Что происходит при неудачной проверке?

Давайте заглянем "под капот" и посмотрим, что делает `tms.Equal`, когда значения не совпадают.

1.  **Вызов `testify/assert`:** Внутри `tms.Equal` сначала вызывается `assert.Equal` из библиотеки `testify`. Эта функция выполняет само сравнение и возвращает `true` (если равны) или `false` (если не равны). Если она возвращает `false`, она также вызывает `t.Errorf` со своим стандартным сообщением.
2.  **Проверка результата:** Функция `tms.Equal` проверяет значение, возвращенное `assert.Equal`.
3.  **Если неудача (`false`):**
    *   **`t.Fail()`:** Вызывается метод `t.Fail()`. Он помечает текущий тест (`*testing.T`) как упавший, но *не останавливает* его выполнение немедленно (в отличие от `t.FailNow()` или `t.Fatalf`).
    *   **Запись информации об ошибке:** Вызывается внутренняя функция `setTestMessage`. Эта функция делает самое важное:
        *   Она находит текущий контекст выполнения (это может быть основной [Результат Теста](07_результат_теста_.md) или текущий [Шаг Теста](03_шаги_теста_.md), или фикстура из [Подготовки и Завершения](04_подготовка_и_завершение__фикстуры__.md)) с помощью механизма контекста горутин (`gls`).
        *   Она получает **трассировку стека** (stack trace) — последовательность вызовов функций, которая привела к ошибке. При этом из трассировки удаляются внутренние вызовы самого адаптера, чтобы она была чище.
        *   Она формирует **сообщение об ошибке**, обычно используя стандартное сообщение от `testify` (например, "Not equal: expected ... actual ...").
        *   Она сохраняет это сообщение и трассировку стека в полях (`message`, `trace`) найденного объекта контекста (теста/шага).
        *   Она также устанавливает статус (`status`) этого объекта контекста в `Failed`.
4.  **Если успех (`true`):** Ничего дополнительного не происходит, выполнение теста продолжается.

Эта записанная информация об ошибке (сообщение, трассировка, статус `Failed`) затем будет автоматически включена в данные, отправляемые [Клиентом Test IT](08_клиент_test_it_.md) на сервер Test IT.

Представим это в виде диаграммы для случая `tms.Equal(t, 5, 6)`:

```mermaid
sequenceDiagram
    participant TestFunc as Ваш Тест
    participant TmsAssert as tms.Equal()
    participant Testify as testify/assert.Equal()
    participant Ctx as Контекст (gls)
    participant TestObj as Текущий Шаг/Тест

    TestFunc->>TmsAssert: tms.Equal(t, 5, 6, "Проверка значения")
    TmsAssert->>Testify: assert.Equal(t, 5, 6, "Проверка значения")
    Testify-->>TmsAssert: Возвращает false (неудача)
    TmsAssert->>TmsAssert: Проверка: неудача? (Да)
    TmsAssert->>TmsAssert: t.Fail() ; Пометить тест (*testing.T) упавшим
    TmsAssert->>TmsAssert: Вызов setTestMessage("Not equal: \nexpected: 5\nactual  : 6")
    activate TmsAssert
        TmsAssert->>Ctx: Получить текущий TestObj (шаг или тест)
        Ctx-->>TmsAssert: Текущий Контекст (TestObj)
        TmsAssert->>TestObj: добавитьСообщение("Not equal: \nexpected: 5\nactual  : 6")
        TmsAssert->>TestObj: добавитьТрассировку(getTrace())
        TmsAssert->>TestObj: установитьСтатус(Failed)
    deactivate TmsAssert
    TmsAssert-->>TestFunc: (Возврат управления, тест помечен как Failed)
```

**Взгляд на код:**

Вот упрощенный пример функции `tms.Equal` из файла `assert.go`:

```go
// Файл: assert.go (упрощено)
package tms

import (
	"fmt"
	"testing"
	"github.com/stretchr/testify/assert" // Импорт testify
)

func Equal(t *testing.T, expected interface{}, actual interface{}, msgAndArgs ...interface{}) {
	// 1. Вызываем оригинальный assert.Equal
	success := assert.Equal(t, expected, actual, msgAndArgs...)

	// 2. Проверяем результат
	if !success {
		// 3. Если неудача:
		//    Формируем сообщение (упрощено, testify уже вывел свое через t.Error)
		errMsg := fmt.Sprintf("Not equal: \n"+
			"expected: %s\n"+
			"actual  : %s", expected, actual)
		//    Записываем детали ошибки в контекст
		setTestMessage(errMsg)
		//    Помечаем тест как упавший (не останавливая его)
		t.Fail()
	}
	// 4. Если успех, ничего не делаем
}
```

А вот как выглядит упрощенная `setTestMessage` из того же файла:

```go
// Файл: assert.go (упрощено)

// Записывает детали ошибки в текущий контекст (шаг или тест)
func setTestMessage(msg string) {
	// Находим текущий объект testResult (представляющий весь тест) в контексте
	манипулироватьОбъектомИзКонтекста(
		ключРезультатаТеста, // Константа для доступа к testResult
		func(test interface{}) {
			// Преобразуем найденный объект к интерфейсу с нужными методами
			деталиСтатусаТеста := test.(интерфейсПолейОшибки)
			// Добавляем трассировку стека (очищенную от вызовов адаптера)
			деталиСтатусаТеста.добавитьТрассировку(получитьТрассировку())
			// Добавляем сообщение об ошибке
			деталиСтатусаТеста.добавитьСообщение(msg)
			// Устанавливаем статус всего теста в Failed
			деталиСтатусаТеста.добавитьСтатус(failed) // failed - константа "Failed"
		})

	// Также помечаем текущий *узел* (шаг или тест) как Failed
	манипулироватьОбъектомИзКонтекста(
		ключУзла, // Константа для доступа к текущему шагу/тесту
		func(node interface{}) {
			узел := node.(интерфейсСтатуса)
			узел.добавитьСтатус(failed)
		})
}

// Возвращает очищенную трассировку стека
func получитьТрассировку() string {
	// Используем assert.CallerInfo() для получения стека
	// Фильтруем строки, содержащие внутренние пакеты адаптера ("pkg/tms", "jtolds/gls")
	// ... (код фильтрации) ...
	// Возвращаем отфильтрованный стек как строку
}

// Вспомогательная функция для работы с контекстом (использует gls)
func манипулироватьОбъектомИзКонтекста(ключ ctxKey, действие func(интерфейс{})) {
    // ... (логика получения объекта из gls по ключу и вызова 'действие') ...
}

// Определения интерфейсов (упрощенно)
type интерфейсПолейОшибки interface {
	добавитьТрассировку(string)
	добавитьСообщение(string)
	добавитьСтатус(string)
}
type интерфейсСтатуса interface {
	добавитьСтатус(string)
}
```

Ключевые моменты здесь:
*   Использование `assert.Equal` из `testify`.
*   Проверка `if !success`.
*   Вызов `t.Fail()`.
*   Вызов `setTestMessage` для записи деталей ошибки (сообщения и трассировки) и установки статуса `Failed` в текущий контекст с помощью `gls`.

## Заключение

В этой главе мы научились использовать функции-проверки (ассерты) из пакета `tms`, такие как `tms.Equal`, `tms.True`, `tms.NoError` и другие. Мы поняли, что это не просто обертки над `testify/assert`, а инструменты, которые автоматически обогащают отчеты в Test IT подробной информацией об ошибках (сообщение, место падения) в случае неудачной проверки. Это делает анализ упавших тестов значительно проще и быстрее.

Использование ассертов — ключевой элемент написания автотестов. Но иногда нам нужно добавить в отчет не только результат проверки, но и другую полезную информацию: логи выполнения, скриншоты, произвольные сообщения. Как это сделать?

Об этом мы поговорим в следующей главе: [Методы Добавления Информации](06_методы_добавления_информации_.md).

---

Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)